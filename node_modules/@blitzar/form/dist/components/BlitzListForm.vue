<template>  
  <div class="blitz-list-form">
    <div
      class="blitz-list-form__row"
      :style="`grid-template-columns: ${gridTemplateColumnsCalculated}`"
    >
      <BlitzField
        v-for="(subfield, fieldIndex) in schemaLabels"
        :key="fieldIndex"
        class="blitz-list-form__sub-field"
        v-bind="subfield"
      />
    </div>
    <div
      class="blitz-list-form__row"
      v-for="(row, rowIndex) in cValue"
      :style="`grid-template-columns: ${gridTemplateColumnsCalculated}`"
      :key="rowIndex"
    >
      <BlitzField
        v-for="(subfield, fieldIndex) in cSchema"
        :key="fieldIndex"
        class="blitz-list-form__sub-field"
        :rowIndex="rowIndex"
        :rowData="cValue[rowIndex]"
        :rowInput="(params) => setSubFieldValue({ id: params.id, value: params.value, rowIndex })"
        :deleteRow="() => deleteRow(rowIndex)"
        v-bind="subfield"
        :value="cValue[rowIndex][subfield.id]"
        @input="
          (val, origin) => setSubFieldValue({ id: subfield.id, value: val, rowIndex }, origin)
        "
        @keyup.native.delete="onDeleteKey(rowIndex, subfield.id)"
      />
    </div>
  </div>
</template>

<script>
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import { merge } from 'merge-anything';
import { copy } from 'copy-anything';
import { isNumber } from 'is-what';
import BlitzField from './BlitzField.vue';
/**
With BlitzListForm you can pass a `schema` just like a BlitzForm. The difference is that BlitzListForm is more like a (as the name says) _**list**_ form. ðŸ˜ƒ

The `schema` you specify is shown as a single row. New rows are added automatically on user input.
 */

export default {
  name: 'BlitzListForm',
  inheritAttrs: false,
  components: {
    BlitzField: BlitzField
  },
  props: {
    /**
     * @category model
     */
    value: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * This is the information on the columns you want to be shown. An array of objects just like a BlitzForm.
     * @example [{ label: 'Amount', id: 'amount', component: 'input', type: 'number', style: 'color: white' }, { label: 'Currency', id: 'curr', component: 'select', slot: [{ component: 'option', value: '', slot: '' }, { component: 'option', value: 'usd', slot: 'USD' }], style: 'color: white' }]
     * @category content
     */
    schema: {
      type: Array,
      default: function _default() {
        return [{
          component: 'input'
        }];
      }
    },

    /**
     * A list of prop (attribute) names to be passed on to each single BlitzField generated in the list form.
     *
     * This is useful when you want to use Evaluated Props in the schema of the mine form but need information from the top level BlitzForm.
     * @example ['formData', 'mode', 'myCustomProp']
     * @category content
     */
    attrsToPass: {
      type: Array,
      default: function _default() {
        return ['formData', 'formDataFlat', 'formId', 'formMode', 'mode', 'fieldInput', 'lang'];
      }
    },

    /**
     * Pass the component names (without `.vue`) that have internal error handling. This makes sure it passes on props like `rules` and does nothing with them in the BlitzField.
     * @type {string[]}
     * @category behavior
     */
    internalErrorsFor: {
      type: Array,
      default: function _default() {
        return ['QInput', 'QSelect', 'QField', 'q-input', 'q-select', 'q-field'];
      }
    },

    /**
     * Allows to limit the max amount of rows.
     * @category content
     */
    maxRows: {
      type: Number
    },
    disable: {
      type: Boolean
    },
    readonly: {
      type: Boolean
    }
  },
  computed: {
    /**
     * This is the value with an empty row concatinated to it.
     */
    cValue: {
      get: function get() {
        var value = this.value,
            schema = this.schema,
            disable = this.disable,
            readonly = this.readonly,
            maxRows = this.maxRows;
        var emptyRow = schema.reduce(function (carry, _ref) {
          var id = _ref.id;
          return Object.assign({}, carry, _defineProperty({}, id, undefined));
        }, {});

        if (!disable && !readonly && (!isNumber(maxRows) || maxRows > value.length)) {
          return value.concat([emptyRow]);
        }

        return value;
      },
      set: function set(val) {
        this.$emit('input', val);
      }
    },
    listFormAttrsToPass: function listFormAttrsToPass() {
      var attrsToPass = this.attrsToPass,
          getPropOrAttrOrParentProp = this.getPropOrAttrOrParentProp,
          value = this.value;
      var attrs = attrsToPass.reduce(function (carry, attrKey) {
        carry[attrKey] = getPropOrAttrOrParentProp(attrKey);
        return carry;
      }, {});

      if (!attrs.formData) {
        return Object.assign({}, attrs, {
          formData: value
        });
      }

      return attrs;
    },
    cSchema: function cSchema() {
      var schema = this.schema,
          disable = this.disable,
          readonly = this.readonly,
          listFormAttrsToPass = this.listFormAttrsToPass,
          internalErrorsFor = this.internalErrorsFor; // slot, class, style are 3 prop names we cannot directly pass via `v-bind`.
      // - slot: we pass as `slots: { default: ... }`
      // - class: we pass as `fieldClasses`
      // - style: we pass as `fieldStyle`

      return schema.map(function (blueprint) {
        var overwritableDefaults = {
          disable: disable,
          readonly: readonly
        };
        var internalErrorDefaults = internalErrorsFor.includes(blueprint.component) ? {
          internalErrors: true
        } : {};
        var overwrites = {
          label: '',
          subLabel: '',
          slots: {
            label: undefined
          }
        };

        if (blueprint.slot) {
          overwrites.slots = merge(blueprint.slots || {}, {
            default: blueprint.slot
          });
        }

        var fieldClasses = blueprint.fieldClasses || blueprint.class;
        if (fieldClasses) overwrites.fieldClasses = fieldClasses;
        var fieldStyle = blueprint.fieldStyle || blueprint.style;
        if (fieldStyle) overwrites.fieldStyle = fieldStyle;
        return merge(listFormAttrsToPass, overwritableDefaults, internalErrorDefaults, blueprint, overwrites);
      });
    },
    schemaLabels: function schemaLabels() {
      var schema = this.schema,
          listFormAttrsToPass = this.listFormAttrsToPass;
      return schema.map(function (subfield) {
        return merge(listFormAttrsToPass, subfield, {
          component: undefined
        });
      });
    },
    gridTemplateColumnsCalculated: function gridTemplateColumnsCalculated() {
      var schema = this.schema;
      return schema.reduce(function (total, field) {
        var fr = Number(field.span);
        if (isNumber(fr)) return "".concat(total, " ").concat(fr, "fr");
        return "".concat(total, " ").concat(field.span || '1fr');
      }, '');
    }
  },
  methods: {
    getPropOrAttrOrParentProp: function getPropOrAttrOrParentProp(propKey) {
      if (propKey in this) return this[propKey];
      if (propKey in this.$attrs) return this.$attrs[propKey]; // TODO: WTF, this is such bad practice... Why did I do this... :'D

      if (propKey in this.$parent) return this.$parent[propKey];
      return this.$parent.$parent[propKey];
    },
    deleteRow: function deleteRow(rowIndex) {
      var value = this.value;
      var allRows = copy(value);
      if (allRows[rowIndex] === undefined) return;
      allRows.splice(rowIndex, 1);
      this.$emit('input', allRows);
    },
    setSubFieldValue: function setSubFieldValue(_ref2, origin) {
      var id = _ref2.id,
          newValue = _ref2.value,
          rowIndex = _ref2.rowIndex;
      // do not emit when the origin is from the default value initialisation
      if (origin === 'default') return;
      var oldValue = this.value;
      var allRows = copy(oldValue);
      if (allRows[rowIndex] === undefined) this.$set(allRows, rowIndex, {});
      allRows[rowIndex][id] = newValue;
      this.$emit('input', allRows);
    },
    onDeleteKey: function onDeleteKey(rowIndex, fieldId) {
      var value = this.value,
          deleteRow = this.deleteRow;
      var allRows = value;
      var row = allRows[rowIndex];
      if (!row) return;

      if (Object.keys(row).every(function (key) {
        return row[key] === '' || row[key] === 0;
      })) {
        deleteRow(rowIndex);
      }
    }
  }
};
</script>

<style>
.blitz-list-form > .blitz-list-form__row {
  display: grid;
  justify-items: stretch;
  align-items: center;
  grid-gap: 8px;
  margin-bottom: 8px;
}
</style>