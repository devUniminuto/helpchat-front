<template>  
  <component
    :is="innerFormComponent"
    ref="refBlitzForm"
    :class="`blitz-form blitz-form--nav-${actionButtonsPosition}`"
  >
    <template v-if="formComponent === 'QForm'">
      <!-- prevent the default behaviour of HTML5 forms being "submitted" on "enter" inside input fields -->
      <button type="submit" disabled style="display: none" aria-hidden="true"></button>
      <!-- navigation buttons row (save, edit, ...) -->
      <div
        :class="`blitz-form__nav-row blitz-form__nav-row--${actionButtonsPosition}`"
        v-if="isFullString(formErrorMsg) || actionButtonsSchema.length"
      >
        <div class="blitz-form__validation-error text-negative" v-if="isFullString(formErrorMsg)">
          {{ formErrorMsg }}
        </div>
        <BlitzField
          v-for="(blueprint, i) in actionButtonsSchema"
          :key="blueprint.id || i"
          v-bind="blueprint"
          v-on="blueprint.events"
        />
      </div>
    </template>
    <!-- form contents -->
    <!-- @slot The default slot is what contains by default the actual form fields. This slot should not be used, unless you are only interested in the logic of BlitzForm and not of BlitzFields. -->
    <slot v-bind="{ schema: cSchema, formDataFlat }">
      <div
        class="blitz-form__form"
        :style="`grid-template-columns:${' 1fr'.repeat(columnCount)}; grid-gap: ${gridGap}`"
      >
        <BlitzField
          v-for="(field, i) in cSchema"
          :key="`${field.id}-${i}`"
          v-bind="{ ...field, span: undefined }"
          :value="formDataFlat[field.id]"
          @input="(value, origin) => fieldInput({ id: field.id, value, origin })"
          :style="
            field.span
              ? `grid-column: ${field.span === true ? '1 / -1' : `span ${field.span}`}`
              : ''
          "
        />
      </div>
    </slot>
  </component>
</template>

<script>
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import { QForm } from 'quasar';
import { merge } from 'merge-anything';
import { copy } from 'copy-anything';
import { isArray, isFunction, isFullString, isPlainObject, isString } from 'is-what';
import { nestifyObject } from 'nestify-anything';
import { flattenPerSchema } from '@blitzar/utils';
import BlitzField from './BlitzField.vue';
import { defaultLang } from '../meta/lang';
import { validateFormPerSchema } from '../helpers/validation';
/**
Here you can find all the information on the available props & events of BlitzForm.

If any of the documentation is unclear, feel free to [open an issue](https://github.com/cycraft/blitzar/issues) to ask for clarification!
 */

export default {
  name: 'BlitzForm',
  components: {
    BlitzField: BlitzField,
    QForm: QForm
  },
  inheritAttrs: false,
  props: {
    /**
     * An object with the data of the entire form. The object keys are the ids of the fields passed in the `schema`.
     *
     * To be used with `:value` or `v-model`.
     * @type {Record<string, any>}
     * @example { name: '' }
     * @category model
     */
    value: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /**
     * A manually set `id` of the BlitzForm. This prop is accessible in the `context` (as `formId`) of any Evaluated Prop and event.
     *
     * Read more on Evaluated Props in its dedicated page.
     * @type {string}
     * @category model
     */
    id: {
      type: String
    },

    /**
     * This is the heart of your BlitzForm. It's the schema that defines what fields will be generated.
     *
     * The possible props you can pass are:
     * - BlitzField props (see BlitzField API Card in the documentation)
     * - any props of the actual component you define
     * @type {Record<string, any>[]}
     * @example [{id: 'name', label: 'Name', component: 'input', style: 'color: white'}, {id: 'age', label: 'Age', component: 'input', type: 'number', style: 'color: white'}]
     * @category model
     */
    schema: {
      type: Array,
      required: true
    },

    /**
     * Buttons on top of the form that control the `mode` of the form. The possible pre-made buttons are:
     * - `'edit'` — a button which puts the form in 'edit' mode & does `emit('edit')`
     * - `'cancel'` — a button which puts the form in 'view' mode & does `emit('cancel')`
     * - `'save'` — a button which puts the form in 'edit' mode & does `emit('save', {newData, oldData})`
     * - `'delete'` — a red button which does `emit('delete')`
     * - `'archive'` — a red button which does `emit('archive')`
     *
     * You can also pass custom buttons with the same schema to generate forms.
     *
     * See the documentation on Action Buttons for more info.
     * @type {('edit' | 'cancel' | 'save' | 'delete' | 'archive' | Record<string, any>)[]}
     * @example ['delete', 'cancel', 'edit', 'save']
     * @example [{component: 'button', type: 'button', slot: 'log', events: {click: console.log}}]
     * @category content
     */
    actionButtons: {
      type: Array,
      default: function _default() {
        return [];
      }
    },

    /**
     * You can overwrite the schema used for the default action buttons for edit, cancel, save, delete & archive.
     * @type {{ edit?: Record<string, any>, cancel?: Record<string, any>, save?: Record<string, any>, delete?: Record<string, any>, archive?: Record<string, any>, }}
     * @example {'save': {push: true}, 'delete': {color: 'secondary'}}
     * @category content
     */
    actionButtonDefaults: {
      type: Object,
      default: function _default() {
        return {};
      }
    },

    /**
     * The position of the action buttons.
     * @type {'top' | 'bottom' | 'right' | 'left'}
     * @category content
     */
    actionButtonsPosition: {
      type: String,
      default: 'top',
      validator: function validator(prop) {
        return ['top', 'bottom', 'right', 'left'].includes(prop);
      }
    },

    /**
     * A function which serves as global validator for your form. It will receive the edited data as first param and the original data (before user edits) as second. It should return true if all is OK or a string with error message.
     * @type {(newData: Record<string, any>, oldData: Record<string, any>) => (true | string)}
     * @example (newData, oldData) => newData.pass1 === newData.pass2 || 'passwords don't match'
     * @category behavior
     */
    validator: {
      type: Function
    },

    /**
     * The amount of columns the form should have. Each field can set a specific 'span' to be able to span multiple columns.
     * @type {number}
     * @category style
     */
    columnCount: {
      type: Number,
      default: 1
    },

    /**
     * The size of the gap between each field in the form.
     * @type {string}
     * @category style
     */
    gridGap: {
      type: String,
      default: '1em'
    },

    /**
     * The text used in the UI for the action buttons and some error messages.
     * @type {{ archive?: string, delete?: string, cancel?: string, edit?: string, save?: string, requiredField?: string, formValidationError?: string } | EvaluatedProp<{ archive?: string, delete?: string, cancel?: string, edit?: string, save?: string, requiredField?: string, formValidationError?: string }>}
     * @example { cancel: 'キャンセル', edit: '編集', save: '保存' }
     * @category content
     */
    lang: {
      type: Object,
      // when changing the default, do it for both BlitzForm; BlitzField and lang.js
      default: function _default() {
        return {
          archive: 'Archive',
          delete: 'Delete',
          cancel: 'Cancel',
          edit: 'Edit',
          save: 'Save',
          requiredField: 'Field is required',
          formValidationError: 'There are remaining errors.'
        };
      }
    },
    // shared props

    /**
     * The mode represents how fields are rendered
     * - `'edit'` — (default) show editable fields based on the schema
     * - `'view'` — show each field with `readonly: true`
     * - `'disabled'` — show each field with `disabled: true`
     * - `'raw'` — used to show raw data of your form (for select components, it will show the data label instead of its value)
     * - `'add'` — the same as `'edit'`
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {'edit' | 'view' | 'disabled' | 'raw' | 'add'}
     * @category state
     */
    mode: {
      type: String,
      default: 'edit',
      validator: function validator(prop) {
        return ['edit', 'view', 'disabled', 'raw', 'add'].includes(prop);
      }
    },

    /**
     * The position of the label in comparison to the field.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {'top' | 'left'}
     * @category style
     */
    labelPosition: {
      type: [String, Function],
      default: 'top',
      validator: function validator(prop) {
        return ['top', 'left'].includes(prop);
      }
    },

    /**
     * Custom styling to be applied to the label of BlitzField. Applied like so `:style="componentStyle"`. Can be an Evaluated Prop.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example 'font-weight: 200;'
     * @category style
     */
    labelStyle: {
      type: [Object, Array, String, Function]
    },

    /**
     * Custom classes to be applied to the label of BlitzField. Applied like so `:class="labelClasses"`. Can be an Evaluated Prop.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string | Record<string, boolean> | (string | Record<string, boolean>)[] | EvaluatedProp<string | Record<string, boolean> | (string | Record<string, boolean>)[]>}
     * @example ['text-h6']
     * @category style
     */
    labelClasses: {
      type: [Object, Array, String, Function]
    },

    /**
     * An array with prop names that should be treated as Evaluated Props when passed a function.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {string[]}
     * @category behavior
     */
    evaluatedProps: {
      type: Array,
      default: function _default() {
        return ['component', 'showCondition', 'label', 'subLabel', 'required', 'rules', 'fieldStyle', 'fieldClasses', 'componentStyle', 'componentClasses', 'disable', 'events', 'lang'];
      }
    },

    /**
     * Set to true if the entire form has its own labels and you do not want the BlitzField to show a label.
     *
     * When `true` subLabels will be passed as a prop called 'hint'.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {boolean | undefined}
     * @category behavior
     */
    internalLabels: {
      type: [Boolean, undefined],
      required: false,
      default: undefined
    },

    /**
     * Set to true if the entire form has its own error handling. This makes sure it passes on props like `rules` and does nothing with them in the BlitzField.
     *
     * This prop can be set on a BlitzField or on a BlitzForm (in which case it's applied to all fields).
     * @type {boolean | undefined}
     * @category behavior
     */
    internalErrors: {
      type: [Boolean, undefined],
      required: false,
      default: undefined
    },

    /**
     * Pass the component names (without `.vue`) that have internal error handling. This makes sure it passes on props like `rules` and does nothing with them in the BlitzField.
     * @type {string[]}
     * @category behavior
     */
    internalErrorsFor: {
      type: Array,
      default: function _default() {
        return ['QInput', 'QSelect', 'QField', 'q-input', 'q-select', 'q-field'];
      }
    },

    /**
     * The component that should be used to generate the form. Defaults to QForm. You can pass the name of a native HTML5 element or Vue component that is globally registered. You can also import the Vue file and directly pass the imported object, just like you would when you add it to a Vue file's components prop.
     * @type {string | Function}
     * @example 'form'
     * @example 'tr'
     * @example 'MyFormWrapper'
     */
    formComponent: {
      type: [String, Function],
      default: 'QForm'
    }
  },
  data: function data() {
    var _this = this;

    var mode = this.mode,
        id = this.id,
        value = this.value,
        schema = this.schema,
        lang = this.lang; // merge user provided lang onto defaults

    var innerLang = merge(defaultLang(), lang);
    var innerMode = mode;
    var formId = id;
    var dataFlat = flattenPerSchema(value, schema);
    var schemaArray = isArray(schema) ? schema : Object.values(schema);
    var dataFlatDefaults = schemaArray.reduce(function (carry, _ref) {
      var id = _ref.id,
          defaultValue = _ref.defaultValue;
      if (!isFullString(id)) return carry;
      carry[id] = isFunction(defaultValue) ? defaultValue(value, _this) : defaultValue;
      return carry;
    }, {});
    var formDataFlat = merge(dataFlatDefaults, copy(dataFlat));
    return {
      innerLang: innerLang,
      innerMode: innerMode,
      formId: formId,
      edited: false,
      editedFields: [],
      formDataFlat: formDataFlat,
      formDataFlatBackups: [copy(formDataFlat)],
      formErrorMsg: '',
      innerFormComponent: this.formComponent === 'QForm' ? QForm : this.formComponent
    };
  },
  watch: {
    mode: function mode(newValue) {
      this.innerMode = newValue;
    },
    id: function id(newValue) {
      this.formId = newValue;
    },
    lang: function lang(newValue) {
      this.innerLang = merge(defaultLang(), newValue);
    }
  },
  computed: {
    formData: function formData() {
      return nestifyObject(this.formDataFlat);
    },
    schemaObject: function schemaObject() {
      return this.schema.reduce(function (carry, blueprint) {
        carry[blueprint.id] = blueprint;
        return carry;
      }, {});
    },
    cMode: {
      get: function get() {
        return this.innerMode;
      },
      set: function set(val) {
        this.innerMode = val;
        this.event('update:mode', val);
      }
    },
    schemaOverwritableDefaults: function schemaOverwritableDefaults() {
      var innerMode = this.innerMode,
          innerLang = this.innerLang;
      return {
        // used here & pass
        lang: innerLang,
        mode: innerMode,
        fieldInput: this.fieldInput,
        // just pass
        labelPosition: this.labelPosition,
        labelStyle: this.labelStyle,
        labelClasses: this.labelClasses,
        evaluatedProps: this.evaluatedProps,
        internalLabels: this.internalLabels,
        internalErrors: this.internalErrors
      };
    },
    schemaForcedDefaults: function schemaForcedDefaults() {
      var formData = this.formData,
          formDataFlat = this.formDataFlat,
          formId = this.formId,
          innerMode = this.innerMode;
      return {
        formData: formData,
        formDataFlat: formDataFlat,
        formId: formId,
        formMode: innerMode
      };
    },
    cSchema: function cSchema() {
      // slot, class, style are 3 prop names we cannot directly pass via `v-bind`.
      // - slot: we pass as `slots: { default: ... }`
      // - class: we pass as `fieldClasses`
      // - style: we pass as `fieldStyle`
      var schema = this.schema,
          schemaOverwritableDefaults = this.schemaOverwritableDefaults,
          schemaForcedDefaults = this.schemaForcedDefaults,
          internalErrorsFor = this.internalErrorsFor;
      return schema.map(function (blueprint) {
        var internalErrorDefaults = internalErrorsFor.includes(blueprint.component) ? {
          internalErrors: true
        } : {};
        var overwrites = {};

        if (blueprint.slot) {
          overwrites.slots = merge(blueprint.slots || {}, {
            default: blueprint.slot
          });
        }

        var fieldClasses = blueprint.fieldClasses || blueprint.class;
        if (fieldClasses) overwrites.fieldClasses = fieldClasses;
        var fieldStyle = blueprint.fieldStyle || blueprint.style;
        if (fieldStyle) overwrites.fieldStyle = fieldStyle;
        var blueprintParsed = merge(schemaOverwritableDefaults, internalErrorDefaults, blueprint, overwrites, schemaForcedDefaults);
        return blueprintParsed;
      });
    },
    actionButtonsMap: function actionButtonsMap() {
      var innerLang = this.innerLang,
          tapDelete = this.tapDelete,
          tapEdit = this.tapEdit,
          tapArchive = this.tapArchive,
          tapCancel = this.tapCancel,
          tapSave = this.tapSave,
          actionButtonDefaults = this.actionButtonDefaults,
          innerMode = this.innerMode;
      var map = {
        delete: {
          component: 'button',
          type: 'button',
          slot: innerLang['delete'],
          color: 'negative',
          events: {
            click: tapDelete
          }
        },
        archive: {
          component: 'button',
          type: 'button',
          slot: innerLang['archive'],
          color: 'negative',
          events: {
            click: tapArchive
          }
        },
        edit: {
          component: 'button',
          type: 'button',
          showCondition: function showCondition() {
            return ['view', 'raw'].includes(innerMode);
          },
          slot: innerLang['edit'],
          events: {
            click: tapEdit
          }
        },
        cancel: {
          component: 'button',
          type: 'button',
          showCondition: function showCondition() {
            return ['edit', 'add'].includes(innerMode);
          },
          slot: innerLang['cancel'],
          events: {
            click: tapCancel
          }
        },
        save: {
          component: 'button',
          type: 'button',
          showCondition: function showCondition() {
            return ['edit', 'add'].includes(innerMode);
          },
          slot: innerLang['save'],
          events: {
            click: tapSave
          }
        }
      };
      return merge(map, actionButtonDefaults);
    },
    actionButtonsSchema: function actionButtonsSchema() {
      var actionButtons = this.actionButtons,
          schemaForcedDefaults = this.schemaForcedDefaults,
          actionButtonsMap = this.actionButtonsMap,
          formDataFlat = this.formDataFlat,
          innerLang = this.innerLang;
      var overwritableDefaults = {
        lang: innerLang,
        fieldInput: this.fieldInput
      };
      return actionButtons.map(function (blueprint) {
        var _bp = isString(blueprint) ? actionButtonsMap[blueprint] : blueprint;

        var slotsOverwrite = !_bp.slot ? {} : {
          slots: merge(_bp.slots || {}, {
            default: _bp.slot
          })
        };
        var events = _bp.events || {};
        var eventsOverwrites = !events.input ? {} : {
          events: {
            input: function input(value, origin) {
              return fieldInput({
                id: field.id,
                value: value,
                origin: origin
              });
            }
          }
        };
        var overwrites = Object.assign({
          span: undefined,
          value: formDataFlat[_bp.id]
        }, slotsOverwrite, eventsOverwrites);
        var blueprintParsed = merge(overwritableDefaults, _bp, overwrites, schemaForcedDefaults);
        return blueprintParsed;
      });
    },
    dataBackup: function dataBackup() {
      var formDataFlatBackups = this.formDataFlatBackups;
      if (!formDataFlatBackups.length) return {};
      var lastBackup = formDataFlatBackups.slice(-1)[0];
      var dataNested = nestifyObject(lastBackup);
      return dataNested;
    },
    dataEdited: function dataEdited() {
      var editedFields = this.editedFields,
          formDataFlat = this.formDataFlat;
      var dataFlat = editedFields.reduce(function (carry, prop) {
        carry[prop] = formDataFlat[prop];
        return carry;
      }, {});
      var dataNested = nestifyObject(dataFlat);
      return dataNested;
    }
  },
  methods: {
    isFullString: isFullString,

    /**
     * @param {'update:mode' | 'field-input' | 'input' | 'edit' | 'cancel' | 'save' | 'delete' | 'archive'} eventName
     * @param {any} payload
     * @param {'default' | 'cancel' | '' | undefined} origin
     */
    event: function event(eventName, payload, origin) {
      if (eventName === 'update:mode') {
        /**
         * This event makes it possible to sync the prop 'mode' like so: `:mode.sync="mode"`
         * @property {'edit' | 'view' | 'disabled' | 'raw' | 'add'} payload event payload
         */
        this.$emit('update:mode', payload);
      }

      if (eventName === 'field-input') {
        /**
         * This event triggers every time a field gets updated.
         *
         * The payload is an object with `id` for the field id and `value` as the new value.
         *
         * The `origin` prop of the event payload is what caused field-input event:
         * - `'default'` means that the event was emitted when the form was mounted and all fields have initialised their default values.
         * - `'cancel'` means that the 'cancel' button was clicked and the event data was reset to what it was before it was edited.
         * - field-input events from user input won't have an origin.
         * - A custom origin can be added when you execute `fieldInput` from inside an evaluatuated prop.
         *
         * @property {{ id: string, value: any, origin?: 'default' | 'cancel' | '' }} payload event payload
         */
        this.$emit('field-input', payload);
      }

      if (eventName === 'input') {
        /**
         * This event enables the form to be usable with `v-model="formData"`
         * @property {{ [id in string]: any }} payload event payload
         * @property {'default' | 'cancel' | '' | undefined} origin the cause of the input event:
         * - `'default'` means that the event was emitted when the form was mounted and all fields have initialised their default values.
         * - `'cancel'` means that the 'cancel' button was clicked and the event data was reset to what it was before it was edited.
         * - input events from user input won't have an origin.
         */
        this.$emit('input', payload, origin);
      }

      if (eventName === 'edit') {
        /**
         * (no payload) The edit-button was tapped and the form was put into "edit" mode
         */
        this.$emit('edit');
      }

      if (eventName === 'cancel') {
        /**
         * (no payload) The cancel-button was tapped and the form was put back into "view" mode & reverted to its original state
         */
        this.$emit('cancel');
      }

      if (eventName === 'save') {
        /**
         * The save-button was tapped and the form was put back into "view" mode & kept the modified content
         * @property {{newData: { [id in string]: any }, oldData: { [id in string]: any }}} payload event payload
         */
        this.$emit('save', payload);
      }

      if (eventName === 'delete') {
        /**
         * (no payload) The delete-button was tapped (you must implement your own logic)
         */
        this.$emit('delete');
      }

      if (eventName === 'archive') {
        /**
         * (no payload) The archive-button was tapped (you must implement your own logic)
         */
        this.$emit('archive');
      }
    },
    fieldInput: function fieldInput(_ref2) {
      var id = _ref2.id,
          value = _ref2.value,
          origin = _ref2.origin;
      // do not emit anything when the field had no `id` on its schema blueprint
      if (id === undefined) return; // no idea why I do this:

      this.edited = true; // keep a list of edited field ids

      if (!this.editedFields.includes(id)) this.editedFields.push(id); // set the new value onto the formData (might be an empty object)

      this.$set(this.formDataFlat, id, value); // emit field-input with field's id and new data

      this.event('field-input', {
        id: id,
        value: value,
        origin: origin
      }); // emit input with entire formData

      this.event('input', this.formData, origin); // do not extract `this` from here
      // if the form has a formErrorMsg, validate gain to check to see if it's solved

      if (isFullString(this.formErrorMsg)) {
        var res = validateFormPerSchema(this.formData, this.schema, this.innerLang);
        var errorsRemain = Object.values(res).some(function (val) {
          return val !== true;
        });
        if (!errorsRemain) this.formErrorMsg = null;
      }
    },
    resetState: function resetState() {
      this.cMode = 'view';
      this.edited = false;
      this.editedFields = [];
      this.formDataFlatBackups.push(copy(this.formDataFlat));
      this.formErrorMsg = '';
    },
    restoreBackup: function restoreBackup() {
      if (!this.formDataFlatBackups.length) return;
      var lastBackup = this.formDataFlatBackups.pop();
      this.formDataFlat = lastBackup;
    },
    tapCancel: function tapCancel() {
      var _this2 = this;

      this.restoreBackup();
      this.resetState();
      var origin = 'cancel';
      Object.entries(this.formDataFlat).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            id = _ref4[0],
            value = _ref4[1];

        // emit field-input with field's id and new data
        _this2.event('field-input', {
          id: id,
          value: value,
          origin: origin
        });
      }); // emit input with entire formData

      this.event('input', this.formData, origin); // do not extract `this` from here

      this.event('cancel');
    },
    validate: function validate() {
      // validate will focus the field with error, so only use it when the user is not typing something else
      var $refs = this.$refs,
          innerLang = this.innerLang,
          validator = this.validator,
          dataEdited = this.dataEdited,
          dataBackup = this.dataBackup,
          schema = this.schema,
          formDataFlat = this.formDataFlat;
      return new Promise(function (resolve, reject) {
        if (isFunction(validator)) {
          var validatorRes = validator(dataEdited, dataBackup);
          if (isFullString(validatorRes)) reject(validatorRes);
        }

        $refs.refBlitzForm.validate().then(function (success) {
          if (success) return resolve();
          reject(innerLang['formValidationError']);
        }).catch(function (e) {
          return reject(innerLang['formValidationError']);
        });
      });
    },
    tapEdit: function tapEdit() {
      this.cMode = 'edit';
      this.event('edit');
    },
    tapSave: function tapSave() {
      var _this3 = this;

      var validate = this.validate,
          dataEdited = this.dataEdited,
          dataBackup = this.dataBackup,
          resetState = this.resetState;
      validate().then(function () {
        var newData = copy(dataEdited);
        var oldData = copy(dataBackup);

        _this3.event('save', {
          newData: newData,
          oldData: oldData
        });

        resetState();
      }).catch(function (formErrorMsg) {
        _this3.formErrorMsg = formErrorMsg;
      });
    },
    tapDelete: function tapDelete() {
      this.event('delete');
    },
    tapArchive: function tapArchive() {
      this.event('archive');
    }
  }
};
</script>

<style>
.blitz-form.q-form {
  display: flex;
}
.blitz-form--nav-top, .blitz-form--nav-bottom {
  flex-direction: column;
}
.blitz-form--nav-left, .blitz-form--nav-right {
  flex-direction: row;
}

.blitz-form__form {
  flex: 1;
  display: grid;
  align-items: stretch;
  justify-items: stretch;
}
.blitz-form__form > .-title {
  grid-column: 1/-1;
}

.blitz-form__nav-row {
  min-height: 42px;
  display: grid;
  justify-content: end;
  align-content: start;
  align-items: center;
  grid-gap: 16px;
}
.blitz-form__nav-row--top {
  order: 0;
  grid-auto-flow: column;
  margin-bottom: 16px;
}
.blitz-form__nav-row--bottom {
  order: 1;
  grid-auto-flow: column;
  margin-top: 16px;
}
.blitz-form__nav-row--right {
  order: 1;
  grid-auto-flow: row;
  margin-left: 16px;
}
.blitz-form__nav-row--left {
  order: 0;
  grid-auto-flow: row;
  margin-right: 16px;
}
</style>